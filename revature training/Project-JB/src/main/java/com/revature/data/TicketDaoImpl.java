package com.revature.data;

import com.revature.entity.Ticket;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

// Here, we are going to implement some methods that interact with the database:
public class TicketDaoImpl implements TicketDao{

    Connection connection;
    private int employeeId;

    // constructor initialize the connection based on our connection factory:
    public TicketDaoImpl() {
        connection = ConnectionFactory.getConnection();
    }

    // take in a ticket object and return the ticket with the updated id
    @Override
    public Ticket insert(Ticket ticket) {
        System.out.println(ticket.toString());
        System.out.println("Now we're in the DAO trying to pass in ticket object to the database");
        // As the code is right now, we insert the same ticket over and over again
        // String sql = "insert into ticket (id, name, species, food) values (default, 'Ashes', 'cat', 'tuna');";

        // This is dangerous, SQLInjection, if we use string concatenation, bad people can sneak in very dangerous commands:
        // very unpredictable
//        String sql = "insert into ticket(id, name, species, food) values (default, " + ticket.getName() + "," +  ticket.getFood();
//        System.out.println(sql);

        // wherever we want to include a value, we leave it as a question mark for now:
        String sql = "insert into ticket(id, amount, description, status, user_id) values (default, ?, ?, ?,?);";

        try {
            // here, we pass in a flag that tells the program that we want to return the generated id:
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            // taking our statement and setting up the values based on where we put the ?
            preparedStatement.setDouble(1, ticket.getAmount());
            preparedStatement.setString(2, ticket.getDescription());
            preparedStatement.setString(3, ticket.getStatus());
            preparedStatement.setInt(4, ticket.getUser_id());
            System.out.println(preparedStatement.toString());

            // we've set up the string, but we haven't executed the statement
            // we use the executeUpdate method whenever we do DML operations (insert, update, delete):
            // going to return the number of records that were updated (or in this case inserted)
            int count = preparedStatement.executeUpdate();
            // we've successfully inserted a single record
            if(count == 1) {
                System.out.println("Ticket added successfully.");
                // Now, we have to get the id that was generated by the database
                // whenever we get a return value from the database, we store it in a result set:
                ResultSet resultSet = preparedStatement.getGeneratedKeys();
                // right when we get our result set, it actually points to nothing, so we increment it:
                resultSet.next();
                /**
                 * Generated id might look like this:
                 * -------
                 * |  1  |
                 * -------
                 */
                // because result sets in general can return multiple values, we have to specify which one we want
                // but in this case, there's only one value so we take the first one
                int generatedId = resultSet.getInt(1);
                // set the id to the original object:
                ticket.setId(generatedId);
            }
            else {
                System.out.println("Something went wrong with the insert!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("Something went wrong when preparing the statement!");
        }

        return ticket;
    }

    // getting data, rather than inserting:
    @Override
    public Ticket getById(int id) {
        String sql = "select * from ticket where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            //
            preparedStatement.setInt(1, id);
            System.out.println(preparedStatement);
            // Now that we've prepared the statement, we just want to execute it:
            // Result set is going to store the return value of the query:
            ResultSet resultSet = preparedStatement.executeQuery();

            // make sure we actually got a value from the query:
            if(resultSet.next()) {
                // parse out and extract the data
                int idDb = resultSet.getInt("id");
                double amount = resultSet.getDouble("amount");
                String description = resultSet.getString("description");
                String status = resultSet.getString("status");
                // use the data to create a ticket object
                Ticket ticket = new Ticket(amount, description, status, idDb);
                // return the ticket object
                return ticket;
            }
            else {
                System.out.println("something went wrong when trying to query for the ticket, ticket might not exist");
            }
        } catch (SQLException e) {
            System.out.println("Something went wrong when trying to retrieve data.");
            e.printStackTrace();

        }
        // if we reach the end of this method, return null
        return null;

        /**
         * if(username already taken)
         * try {
         * throw new RegisterException
         * }
         * catch RegisterException{
         * print stackTrace
         */
    }

  @Override
    public List<Ticket> getAllTickets() {
        // set up a list to store the return values (tickets)
        List<Ticket> tickets = new ArrayList<>();

        // no actual parameter values here
        String sql = "select * from ticket;";
        try {
            // Use a simple statement here, because we don't have to change any parameters:
            Statement statement= connection.createStatement();

            ResultSet resultSet = statement.executeQuery(sql);

            // As opposed to :
            // PreparedStatement preparedStatement = connection.prepareStatement(sql);
            // statement.executeQuery()

            // now we're getting multiple tickets, so we use the while loop
            // we use a while loop that keeps incrementing the result set until we reach the end (null)
            while(resultSet.next()) {
                // for the current row, extract the data
                int id = resultSet.getInt("id");
                double amount = resultSet.getDouble("amount");
                String description = resultSet.getString("description");
                String status = resultSet.getString("status");
                Ticket ticket = new Ticket(amount, description, status, id);

                // add the current ticket to the list of tickets that we're returning:
                tickets.add(ticket);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // at the very end, return tickets:
        return tickets;
    }

    // For update, we take in some information and update a pre-existing record in the table:
    @Override
    public Ticket update(Ticket ticket) {
        //        String sql = "insert into ticket(id, amount, description, status, user_id) values (default, ?, ?, ?,?);";
        String sql = "update ticket set amount = ?, description = ?, status = ? where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setDouble(1, ticket.getAmount());
            preparedStatement.setString(2, ticket.getDescription());
            preparedStatement.setString(3, ticket.getStatus());
            preparedStatement.setInt(4, ticket.getId());

            //preparedStatement.setInt(4, ticket.getUser_id());

            int count = preparedStatement.executeUpdate(); // DML, we use executeUpdate instead of executeQuery

            if(count == 1) {
                System.out.println("Update successful!");
                return ticket;
            }
            else {
                System.out.println("Something went wrong with the update");
                if(count == 0) {
                    System.out.println("No rows were affected");
                }
                else {
                    System.out.println("Many rows were affected");
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        // return null
        return null;
    }

    // only update a certain field/column:
//    public Ticket updateFood(int id, String food) {
//        String sql = "update pet set food = ? where id = ?;";
//        PreparedStatement preparedStatement = connection.prepareStatement();
//        preparedStatement.setString(food);
//        preparedStatement.setInt(2, id);
//
//    }

    // return a boolean of whether the deletion was successful:
    @Override
    public boolean delete(int id) {
        String sql = "delete from ticket where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, id);

            int count = preparedStatement.executeUpdate();
            if(count == 1) {
                System.out.println("Deletion successful!");
                return true;
            }
            else {
                return false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    //
    @Override
    public boolean claim(int employeeId, int ticketId) {
        // TODO check if id is null
        String sql = "update ticket set user_id = ? where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, employeeId);
            preparedStatement.setInt(2, ticketId);
            int count = preparedStatement.executeUpdate();
            // if we've successfully updated the table, we can return true
            if(count == 1) return true;
        } catch(SQLException e) {
            e.printStackTrace();
        }
        // for failure situations, we return false
        return false;
    }

    // given an employee id, return a list of tickets that they've claimed
    @Override
    public List<Ticket> getClaimedTickets(int employeeId) {
        String sql = "select * from ticket where user_id = ?;";
        List<Ticket> tickets = new ArrayList<>();
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, this.employeeId);
            ResultSet resultSet = preparedStatement.executeQuery();


            while(resultSet.next()) {
                // for the current row, extract the data
                int id = resultSet.getInt("id");
                double amount = resultSet.getDouble("amount");
                String description = resultSet.getString("description");
                String status = resultSet.getString("status");
                Ticket ticket = new Ticket(amount, description, status, id);

                // add the current ticket to the list of tickets that we're returning:
                tickets.add(ticket);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return tickets;
    }

    // CRUD Methods:


}
